// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model LedgerEntry {
  id        String   @id
  intent    Json
  decision  Json
  hash      String
  createdAt DateTime @default(now())

  @@index([createdAt])
}

model AgentState {
  agentId     String   @id
  ttvBaseline Float
  updatedAt   DateTime @updatedAt
}

model ChatThread {
  id         String    @id @default(cuid())
  createdAt  DateTime  @default(now())
  sealedAt   DateTime? // Tier-1 closure: immutable after seal
  finalized  Boolean   @default(false) // Tier-2 closure: canonical immutability
  
  messages   ChatMessage[]
  
  @@index([sealedAt])
  @@index([finalized])
}

model ChatMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  sealedAt  DateTime? // Tier-1 closure: immutable after seal
  finalized Boolean  @default(false) // Tier-2 closure: canonical immutability

  author    ChatAuthor
  text      String

  resolution ChatResolution

  intentId  String?
  intent    Intent? @relation(fields: [intentId], references: [id])

  supersedesMessageId String?
  
  threadId  String?
  thread    ChatThread? @relation(fields: [threadId], references: [id])
  
  @@index([sealedAt])
  @@index([finalized])
}

model Intent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  sourceMessageId String
  sourceMessage   ChatMessage @relation(fields: [sourceMessageId], references: [id])

  intentType IntentType
  goal       String
  constraints String[]

  admissibility AdmissibilityStatus
  denialReason  String?

  execution Execution?
}

model Execution {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  intentId  String @unique
  intent    Intent @relation(fields: [intentId], references: [id])

  status ExecutionStatus
  artifacts String[]
  
  executionContextHash String? // Snapshot of execution scope
  tokenBuffer          Json?   // Buffered tokens for ledger-proofed streaming
  
  @@index([executionContextHash])
}

model DeniedDecision {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  
  actionId       String
  reasonCodes    String[] // DenialReasonCode enum values
  missingCanonIds String[]
  violatedInvariantIds String[]
  requiredCanonRefs String[]
  message        String
  context        Json?
  
  proofHash      String   // Hash of denial proof for audit
  
  @@index([actionId])
  @@index([proofHash])
}

model CanonKnowledge {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  level     String   // CanonLevel: EVIDENCE, PROPOSED, CANON
  itemId    String   @unique
  kind      String   // DEFINITION, INVARIANT, CONSTRAINT
  
  title     String
  statement String
  
  confidence Float   @default(1.0) // ConfidenceEnvelope weight
  trust     Float   @default(1.0) // ConfidenceEnvelope trust
  
  promotedAt DateTime?
  
  @@index([level])
  @@index([kind])
  @@index([promotedAt])
}

enum ChatAuthor {
  USER
  BICKFORD
}

enum ChatResolution {
  CAPTURED
  DENIED
  EXECUTING
  REALIZED
}

enum IntentType {
  OBSERVE
  QUERY
  CHANGE
  AUTOMATE
}

enum AdmissibilityStatus {
  PENDING
  ALLOWED
  DENIED
}

enum ExecutionStatus {
  QUEUED
  RUNNING
  FAILED
  SUCCEEDED
}
